---
title: 'ì •ë ¬ì€ í”„ë¡ íŠ¸ê°€ í•˜ëŠ”ì§€ ë°±ì—”ë“œê°€ í•˜ëŠ”ì§€'
subTitle: 'ì–´ë–¤ê²Œ ë” íš¨ìœ¨ì ì¸ì§€ ë¹„êµí•˜ê¸°'
date: '2024-03-12'
tag: 'TIL'
thumbnail: './imgs/6/1.png'
thumbnail_alt: 'ê° ë¸Œë¼ìš°ì €ì—ì„œ px, em, rem ì§€ì› ì—¬ë¶€'
---

# ì‹œì‘

![history response data êµ¬ì¡°](./imgs/6/1.png)

ê°ì²´ ë°°ì—´ ì•ˆì˜ ê°ì²´ ë°°ì—´ ì•ˆì˜ string ê°’ì„ ì´ìš©í•´ì„œ ê°ì²´ ë°°ì—´ì„ ì •ë ¬í•˜ê³  ì •ë ¬ëœ ê°ì²´ ë°°ì—´ë¼ë¦¬ í•œ ë²ˆ ë” ì •ë ¬ì„ í•´ì•¼ í•˜ëŠ”
ì‚´ì§ ë³µì¡í•œ ì •ë ¬ì„ êµ¬í˜„í•´ì•¼ í•œë‹¤.

ì„œë²„ì—ì„œ ì •ë ¬ì„ í•˜ë©´ ì„œë²„ ë¦¬ì†ŒìŠ¤ê°€ ë“¤ê¸°ì— FEì—ì„œ ì²˜ë¦¬í•˜ëŠ” ê²ƒì´ ì¢‹ë‹¤ëŠ” ì–˜ê¸°ë¥¼ ë“¤ì€ ê¸°ì–µì´ ìˆì–´ì„œ ì´ë¥¼ FEì—ì„œ ì²˜ë¦¬í•˜ë ¤ê³  í•˜ì˜€ì—ˆë‹¤.

```tsx
const handleFilterSelection = (selectedFilter: filterOptionTypes) => {
  setSelectedFilter(selectedFilter);

  const getFullDateFormat = (stringDate: string) => {
    const [yearA, monthA, dayA] = stringDate.split(' - ')[0].split('. ');

    return `20${yearA}-${monthA}-${dayA}`;
  };

  let newHistoryGroup: Group[] = [];

  if (selectedFilter === 'ìµœì‹ ìˆœ') {
    newHistoryGroup = [...historyGroup].sort((a, b) => b.year - a.year);
    newHistoryGroup.forEach(({ objList }: { objList: IObjective[] }) => {
      return objList.sort((a, b) => {
        const fullDateA = getFullDateFormat(a.objPeriod);
        const fullDateB = getFullDateFormat(b.objPeriod);

        return new Date(fullDateB).getTime() - new Date(fullDateA).getTime();
      });
    });
  } else if (selectedFilter === 'ì˜¤ë˜ëœ ìˆœ') {
    const newHistoryData = [...historyOriginGroup]
      .map(({ year, objList }) => {
        const filteredObjList = objList.filter(
          ({ objCategory }: { objCategory: string }) =>
            objCategory === selectedTheme,
        );

        return { year, objList: filteredObjList };
      })
      .filter(({ objList }) => objList.length !== 0);

    historyGroup = [...newHistoryData];

    newHistoryGroup = [...historyGroup].sort((a, b) => a.year - b.year);
    newHistoryGroup.forEach(({ objList }: { objList: IObjective[] }) =>
      objList.sort((a, b) => {
        const fullDateA = getFullDateFormat(a.objPeriod);
        const fullDateB = getFullDateFormat(b.objPeriod);

        return new Date(fullDateA).getTime() - new Date(fullDateB).getTime();
      }),
    );
  } else if (selectedFilter === 'ë‹¬ì„±ë¥  ìˆœ') {
    newHistoryGroup = [...historyGroup].sort((a, b) => b.year - a.year);
    newHistoryGroup.forEach(({ objList }: { objList: IObjective[] }) => {
      return objList.sort((a, b) => b.progress - a.progress);
    });
  }

  historyGroup = [...newHistoryGroup];
};
```

ì¡°ê¸ˆ ê¸¸ê³  ë³µì¡í•´ ë³´ì´ì§€ë§Œ chat GPTê°€ ìˆì—ˆê¸°ì— ìœ„ì˜ ì½”ë“œë¥¼ ì‘ì„±í•˜ëŠ”ë° ê·¸ë¦¬ ì˜¤ë˜ ê±¸ë¦¬ì§€ëŠ” ì•Šì•˜ë‹¤.

ì •ë ¬ ë¡œì§ì„ ë‹¤ êµ¬í˜„í–ˆê¸°ì— ì„œë²„ì—ì„œ ì •ë ¬í•˜ëŠ” ê±´ í•„ìš” ì—†ì–´ì ¸ì„œ ì´ë¥¼ ì œê±°í•´ë„ ëœë‹¤ê³  ì–˜ê¸°í–ˆë”ë‹ˆ ì—°ì„œê°€ BEì—ì„œ í•˜ëŠ” ê²ƒì´ ë” ì¢‹ì„ ê±° ê°™ë‹¤ê³  interruptë¥¼ ê±¸ì–´ì™”ë‹¤.

ê·¸ë˜ì„œ ì´ì— ëŒ€í•´ ê³µë¶€ë¥¼ ì¢€ ë” í•´ë³´ê¸°ë¡œ í•˜ì˜€ë‹¤.

# FE vs BE

ì´ì™€ ê´€ë ¨ëœ ì •ë³´ë“¤ì„ ì¡°ì‚¬í•˜ì˜€ê³  ì´ë¥¼ ì•„ë˜ì— ì •ë¦¬í•´ ë³´ì•˜ë‹¤.

## BEì—ì„œ í•´ì•¼ í•œë‹¤.

> I think in general it is a good principle to avoid doing excessive computation on the client. You don't know if your user is on a top of the range enthusiast PC or a netbook from 10 years ago. Obviously sorting 100 items in an array on its own is probably not going to be noticeable on either computer but...this could end being the first of many things that end up on the front end and before you know it users are complaining and you have a load of little things like this to unpick!
> Not sure either why you would need two API calls to sort things, could you not just request your list of items be sorted on the initial request?

ì¼ë°˜ì ìœ¼ë¡œ í´ë¼ì´ì–¸íŠ¸ì—ì„œ ê³¼ë„í•œ ê³„ì‚°ì„ í”¼í•˜ëŠ” ê²ƒì´ ì¢‹ì€ ì›ì¹™ì´ë¼ê³  ìƒê°í•œë‹¤. ì‚¬ìš©ìê°€ ì •ë§ ì•ˆ ì¢‹ì€ ì„±ëŠ¥ì˜ ì»´í“¨í„°ë¥¼ ì‚¬ìš©í•  ì§€ë„ ëª¨ë¥´ë‹ˆ.

> Oftentimes is less about how fast the "language" does the sorts so much as hinging on the processing power of a machine the user is running. Javascript might sort an array of a billion items faster on a Ryzen 9 than C# can on an i3. That's variability on user hardware is one of the biggest reasons people would opt for server -- to ensure consistent performance.
> That said where is the data coming from? My first priority on a sort would be on the database level, which is usually preferable to a server sort. If you're using SQL it would be using "ORDER BY" or something equivalent in another DB. Offload that work to your DB which is designed specifically to do that work efficiently, and take the burden off both your server and client.

ì–¸ì–´ë³´ë‹¤ëŠ” ì‚¬ìš©í•˜ëŠ” ì»´í“¨í„°ì˜ ì„±ëŠ¥ì— ë”°ë¼ ì •ë ¬ ì†ë„ê°€ ê²°ì •ëœë‹¤. ê·¸ë ‡ê¸°ì— ì„œë²„ì—ì„œ ì •ë ¬í•˜ëŠ” ê±¸ ì„ í˜¸í•œë‹¤. í•˜ì§€ë§Œ ì„œë²„ì˜ ë¶€ë‹´ì„ ì¤„ì´ê¸° ìœ„í•´ DBì—ì„œ ì •ë ¬í•˜ëŠ” ë°©ë²•ì„ ì„ í˜¸í•˜ê¸°ëŠ” í•˜ë‹¤.

> If you want speed, the best way is to sort in the database and retrieve with a limit (pagination) then send to the front-end together with the count of all results.
> Iterating over large volumes of data will slow down or even lock your backend, on the other hand, the database has built-in mechanisms for sorting. Also, make sure to add indexes to make it even faster.

ì†ë„ë¥¼ ìœ„í•œë‹¤ë©´ DBì—ì„œ ì •ë ¬ì„ í•˜ê³ , í˜ì´ì§€ë„¤ì´ì…˜ ê°™ì€ ì œí•œì„ ë‘” ë’¤ ì´ë¥¼ FEì— ì œê³µí•˜ëŠ” ê²ƒì´ ì¢‹ë‹¤.
í•˜ì§€ë§Œ ëŒ€ìš©ëŸ‰ì˜ ë°ì´í„°ë¥¼ ë°˜ë³µí•´ì„œ ë°›ì•„ì˜¤ê²Œ í•˜ëŠ” ê²ƒì€ ì†ë„ë¥¼ ëŠ¦ì¶œ ê²ƒì´ë‹¤.

> Depends on from where data come, how much of it do you have, and what goals you want to achieve.
> Frontend based solution is cost less server CPU but could become terrible user experience. Imagine an array of 100000 features sorted in IE installed on old PC? It could hang the browser.
> So if you have hot much data to process or CPU economy on server is important for you use frontend, otherwise backend.

data ì–‘ì´ í° arrayë¼ë©´ ë˜ ì´ê±¸ ì„±ëŠ¥ ì•ˆ ì¢‹ì€ ì»´í“¨í„°ì—ì„œ ëŒë¦°ë‹¤ë©´ ë¶„ëª… ì‚¬ìš©ì ê²½í—˜ì˜ ì§ˆì´ ë–¨ì–´ì§ˆ ê²ƒì´ë‹¤.
ê·¸ëŸ¬ë‹ˆ ì„œë²„ì˜ CPU í™˜ê²½ ë“±ì´ ì¤‘ìš”í•˜ë‹¤ë©´ FEì—ì„œ, ê·¸ëŸ¬ì§€ ì•Šë‹¤ë©´ BEì—ì„œ ëŒë ¤ë¼.

> A RESTful API is built for the purpose of a developer using it. The values it returns, the errors it presents, even the headers are all part of the "user experience" a developer has when using your API.
> Now you need to weigh that against performance concerns. Is it potentially lots of data? Can you limit that data through paging, etc.? Doing a long sort operation on your server can, in unchecked situations, provide a severely degraded experience for not only that user but also others.
> That said, a server typically has a lot more power for sorting and even (using the right language/algorithm) could provide a multithreaded approach to the problem. So if you're not worried about performance impacts server side, in almost all cases I would do it on the server.

ì¼ë°˜ì ìœ¼ë¡œ ì„œë²„ëŠ” ì •ë ¬ ë° (ì ì ˆí•œ ì–¸ì–´/ì•Œê³ ë¦¬ì¦˜ì„ ì‚¬ìš©í•˜ì—¬) ë¬¸ì œì— ëŒ€í•œ ë‹¤ì¤‘ ìŠ¤ë ˆë“œ ì ‘ê·¼ ë°©ì‹ì„ ì œê³µí•  ìˆ˜ ìˆëŠ” ë” ë§ì€ íŒŒì›Œë¥¼ ê°€ì§€ê³  ìˆë‹¤. ë”°ë¼ì„œ ì„œë²„ ì¸¡ì—ì„œ ì„±ëŠ¥ì— ëŒ€í•œ ìš°ë ¤ê°€ ì—†ë‹¤ë©´ ê±°ì˜ ëª¨ë“  ê²½ìš°ì— ì„œë²„ì—ì„œ ìˆ˜í–‰í•˜ëŠ” ê²ƒì´ ì¢‹ë‹¤.

## FEì—ì„œ í•´ì•¼ í•œë‹¤.

> Q. But if I wanted 10 different sort methods for that list of data. That would be 10 different API calls to get the data from the server.
> The lists won't ever really be past 100 objects. So I guess my question is. Even a shoddy computer would handle that fine I take it?

í•˜ì§€ë§Œ ë°ì´í„°ì˜ ì–‘ì´ ì‘ê³ , ì—¬ëŸ¬ ê°œì˜ ë°©ë²•ìœ¼ë¡œ ì •ë ¬ì„ í•˜ê³  ì‹¶ë‹¤ë©´?

> A. Yeah for sure if something is that small it should be no problem to offload to client. Particularly if you're giving the option of multiple different types of sort and don't want to have to wait for a server roundtrip with each click.
> The main thing to be congnizant of in situations like that I guess is just how often "it only ever needs to be X" suddenly changes. That depends on who is controlling the business requirements.
> In the end if the size of the array does end up increasing and you do begin to notice performance issue with client side sorts, usingÂ *web workers*Â is a good solution to keep sorts client side without locking the UI.

ë°ì´í„° ì–‘ì´ ì‘ë‹¤ë©´ ê·¸ë ‡ê²Œ í•´ë„ ëœë‹¤. íŠ¹íˆ ë§¤ ë²ˆì˜ ì •ë ¬ë§ˆë‹¤ ë°ì´í„°ë¥¼ ê¸°ë‹¤ë¦¬ëŠ” ê²ƒì´ ì‹«ë‹¤ë©´ ë§ì´ë‹¤.
í•˜ì§€ë§Œ ì–¸ì  ê°„ ìš”êµ¬ ì‚¬í•­ì´ ë³€í™”í•  ê²ƒì´ë‹¤. ê·¸ë ‡ë‹¤ë©´ ì´ì— ë§ê²Œ ëŒ€ì‘ì„ í•´ì•¼í•  ê²ƒì´ë‹¤. web workerë¥¼ ì‚¬ìš©í•˜ëŠ” ê²ƒë„ ì¢‹ì€ ë°©ë²•ì´ë‹¤.

> Your API will be used byÂ *n*Â clients. Performance-wise it would make sense to have each client do the sorting on their own instead of having the server do it for all theÂ *n*Â clients. Simply, less CPU work for the server.
> Furthermore, whether the result needs to be sorted or not depends on the nature of the application using the data. Let the application decide that. Some interfaces allow the user to decide what to sort by, thereby convenient to do it locally (without waiting for a background HTTP call).
> However I would not overthink the performance part before you actually have a performance problem. It could also be that the data sorting is not really costly or the sorting has already been done depending on how information is kept internally (in DBMS-s, for example).
> With up to 20 rows without sorting, it really makes no important difference - make the API implementing developers' life easier and do the small sorting on the frontend side.

nê°œì˜ clientê°€ APIë¥¼ ìš”ì²­í•  ê²ƒì´ë‹¤. ê·¸ë•Œë§ˆë‹¤ ì •ë ¬í•´ì„œ ì£¼ëŠ” ê²ƒì€ server CPUì˜ ë‚­ë¹„ê°€ ë  ìˆ˜ ìˆë‹¤.
ë°ì´í„°ê°€ ì •ë ¬ë  ì§€ ë§ì§€ëŠ” application ë”´ì—ì„œ ê²°ì •ë˜ëŠ” ê²ƒì´ë¯€ë¡œ ê±°ê¸°ì„œ ì •ë ¬ì´ ë°œìƒë˜ê²Œ í•´ë¼.
í•˜ì§€ë§Œ ì„±ëŠ¥ì ìœ¼ë¡œ ë¬¸ì œê°€ ë°œìƒí•˜ëŠ” ê²ƒì´ ì•„ë‹ˆë¼ë©´ ê·¸ëƒ¥ í•´ë¼.

## ì •ë¦¬

FEë³´ë‹¤ëŠ” BEì—ì„œ í•˜ëŠ” ê²ƒì´ ë‚«ë‹¤ë¼ëŠ” ë‹µë³€ì„ ë” ë§ì´ ì°¾ì„ ìˆ˜ ìˆì—ˆë‹¤.

ê·¸ì— ëŒ€í•œ ì´ìœ ë¡œëŠ” ì•„ë˜ì™€ ê°™ë‹¤.

1. ì‚¬ìš©ìì˜ ì»´í“¨í„° ì„±ëŠ¥ì´ ì•ˆ ì¢‹ì„ ìˆ˜ë„ ìˆë‹¤. ì´ëŸ° ê²½ìš° FEì—ì„œ ì²˜ë¦¬í•˜ê²Œ ë˜ë©´ ì‹¬ê°í•œ ì‚¬ìš©ì ê²½í—˜ì„ ì´ˆë˜í•  ê²ƒì´ë‹¤.
2. ì¼ë°˜ì ìœ¼ë¡œ ì„œë²„ê°€ ì •ë ¬ ë¬¸ì œì— ëŒ€í•œ ë‹¤ì¤‘ ìŠ¤ë ˆë“œ ì ‘ê·¼ ë°©ì‹ì„ ì œê³µí•  ìˆ˜ ìˆëŠ” ë” ë§ì€ íŒŒì›Œë¥¼ ê°€ì§€ê³  ìˆê¸°ì—, ì„œë²„ ì„±ëŠ¥ì— ëŒ€í•œ ìš°ë ¤ê°€ ì—†ë‹¤ë©´ ì„œë²„ì—ì„œ í•˜ëŠ” ê²ƒì´ ì¢‹ë‹¤.

ê·¸ ë°˜ëŒ€ ì˜ê²¬ìœ¼ë¡œëŠ”

1. ì„œë²„ì˜ ë¶€ë‹´ì„ ì¤„ì—¬ì¤€ë‹¤.
2. ë§¤ ì •ë ¬ ë•Œë§ˆë‹¤ ë°ì´í„° ìš”ì²­ì„ ê¸°ë‹¤ë¦´ í•„ìš” ì—†ë‹¤.
3. ë°ì´í„°ì˜ ì–‘ì´ ì‘ë‹¤ë©´ ì–´ë””ì„œ ì²˜ë¦¬ë¥¼ í•´ë„ ë³„ ìƒê´€ì´ ì—†ë‹¤.

ê°€ ìˆì—ˆë‹¤.

ê·¸ ì™¸ ì¶”ê°€ì ìœ¼ë¡œ ì–»ì€ ì •ë³´ë¡œëŠ” ì•„ë˜ì™€ ê°™ë‹¤.

1. DBì—ì„œ ì •ë ¬ì„ í•˜ëŠ” ê²ƒì´ FE, BE ë‘˜ ë‹¤ ë¦¬ì†ŒìŠ¤ë¥¼ ì¤„ì—¬ì¤„ ê²ƒì´ë‹¤.
2. FEì—ì„œ Web Workerë¥¼ ì´ìš©í•´ì„œ ì²˜ë¦¬í•˜ë©´ ë¹„ë™ê¸°ì ìœ¼ë¡œ ì²˜ë¦¬í•  ìˆ˜ ìˆë‹¤.

# ê²°ë¡ 

ìœ„ì˜ í•™ìŠµí•œ ë‚´ìš©ë“¤ì„ í† ëŒ€ë¡œ ì•„ë˜ì™€ ê°™ì€ ê²°ë¡ ì„ ë‚´ë¦¬ê²Œ ë˜ì—ˆë‹¤.

**DBì—ì„œ ì •ë ¬ì„ í•˜ê³  í•„ìš”í•˜ë‹¤ë©´ ì„œë²„ ìª½ì—ì„œ ì¶”ê°€ ì •ë ¬ì„ í•œ í›„ ì´ë¥¼ pagination ë“±ì˜ ì œí•œì„ ê±¸ì–´ì„œ FEì— ë„˜ê²¨ì¤€ë‹¤.**

ë‚´ê°€ ìƒê°í•œ ê²°ë¡ ì´ ê´œì°®ì€ì§€ ì„ ë°° ê°œë°œìë“¤ì—ê²Œ ì—¬ì­¤ë³´ì•˜ë‹¤.
ì´ì— ëŒ€í•´ ì•„ë˜ì™€ ê°™ì€ ë‹µë³€ì„ ë°›ì•˜ë‹¤.

> ğŸ’¡ pagination ë“±ì´ ë“¤ì–´ê°€ë©´ FEì—ì„  ì •ë ¬ì„ í•  ìˆ˜ê°€ ì—†ê¸°ì— ì„œë²„ ë¦¬ì†ŒìŠ¤ ì—†ì´ ë¹ ë¥´ê²Œ í…ŒìŠ¤íŠ¸í•˜ëŠ” ê²½ìš°ë¥¼ ì œì™¸í•˜ê³ ëŠ” ê¸°ë³¸ì ìœ¼ë¡  ì„œë²„ì—ì„œ ì‘ì—…ì„ í•œë‹¤.
> ë˜í•œ ì—¬ëŸ¬ í”Œë«í¼ì„ ì§€ì›í•˜ëŠ” í”„ë¡œë•íŠ¸ì˜ ê²½ìš°, ê° í”Œë«í¼ì— ë§ê²Œ ë¡œì§ì„ ë‘ì–´ ë™ì‘ì„ í†µì¼í•˜ëŠ” ê²ƒì€ ê½¤ë‚˜ ì–´ë ¤ìš´ ì¼ì´ë‹¤. ê·¸ë ‡ê¸°ì— í™•ì¥ì„±ì„ ìœ„í•´ì„œë¼ë„ ì„œë²„ì—ì„œ ì²˜ë¦¬í•˜ëŠ” ê²ƒì´ ì¢‹ë‹¤ê³  ìƒê°í•œë‹¤.

ì¶”ê°€ë¡œ ì—°ì„œê°€ ì´ëŸ° ì–˜ê¸°ë„ ë“¤ì—ˆë‹¤ê³  í•œë‹¤.

> ğŸ’¡ ì„œë²„ì—ì„œ ì •ë ¬ì— ë¦¬ì†ŒìŠ¤ê°€ ë“œëŠ”ê²Œ ë§ê¸´ í•˜ì§€ë§Œ ê·¸ê±° ë•Œë¬¸ì— ì„±ëŠ¥ì— ì´ìŠˆê°€ ìƒê¸¸ ì •ë„ë¼ë©´ ì •ë ¬ ë¡œì§ì— ë¬¸ì œê°€ ìˆëŠ”ê²Œ ë§ë‹¤.

ê·¸ë˜ì„œ ê·¸ëƒ¥ ì„œë²„ì—ì„œ ì²˜ë¦¬í•˜ëŠ” ê²ƒì´ ì¢‹ì„ ê±° ê°™ë‹¤.

ì •ë ¬ ë¡œì§ ìì²´ëŠ” ì™„ì„±í–ˆì§€ë§Œ í…Œë§ˆë‚˜ ì—°ë„ë¥¼ ì„ íƒí•œ í›„ ì •ë ¬ì„ ì‹œí‚¤ëŠ” ê²ƒì´ êµ‰ì¥íˆ ì–´ë ¤ì›Œì„œ ë©°ì¹  ì§¸ ë™ë™ ì•“ê³  ìˆì—ˆëŠ”ë° ì´ê±¸ ì„œë²„ì—ê²Œ ë„˜ê¸¸ ìˆ˜ ìˆê²Œ ë˜ì–´ ê¸°ì˜ë‹¤. ë™,,
ë™,, í•µê¿€ë§ˆ~
ì•„ì‹¸ëµ¹

# ì°¸ê³ ìë£Œ

[sorting small to medium sized data, front-end vs back-end for speed.](https://www.reddit.com/r/softwaredevelopment/comments/r80mng/sorting_small_to_medium_sized_data_frontend_vs/)
[Array sorting in Front-end or Back-end](https://stackoverflow.com/questions/43414603/array-sorting-in-front-end-or-back-end)
[Choosing the best JavaScript sorting algorithm for your project - LogRocket Blog](https://blog.logrocket.com/choosing-javascript-sorting-algorithm/#sorting-algorithms-frontend-vs-backend-systems)
